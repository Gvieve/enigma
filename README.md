## Enigma Individual Final Project Self Assessment

### Genevieve Nuebel


#### Functionality - 3
  I believe I completed all of the functionality requirements up to iteration 3. My project successfully can encrypt and decrypt messages following the given interaction pattern in project requirements, both via pry and the command line interface. I did not tackle the final iteration of creating a `crack` method and therefore, I don't believe my score should exceed a 3.

#### Object Oriented Programming - 3.5
  I created an enigma class that meets the project spec requirements. I decided to extract some of the methods from that class into two modules. The `Generateable` module is used to generate the many data components needed to encrypt or decrypt a message. Such as, generating a 5 digit key as a string, an alphabet array that includes a `" "` as the 27th element, and so on. My thought was all of the methods that are just creating a value that supports the encrypt or decrypt message that did not store any state, did not need to be within the Engima class. I also created a `Validateable` module to confirm the message, key and date are the correct format and size if given by the user. Specifically, to ensure a user input key "123A5" or date "01234" are not accepted because they contain non-numeric values or are the incorrect length. I could not think of a way to extract things in a superclass based on the way I built the `create_encrypt/decrypt_message` methods. Therefore, I am unsure if I would qualify for a 4.

#### Ruby Conventions and Mechanics - 4
  I do believe that I hit the mark as far as Ruby convention and mechanics. I used several things that were a bit new, such as ARGV and working with files in Ruby. I also learned some new syntactic sugar like using a ternary operator instead of nesting an if/else statement within an iteration to make the code more readable. I believe the code is easy to follow. No methods are over 10 lines because I used many helper methods if a method became too verbose or violated SRP. I also avoided nested iterations where possible, and when used I believe I chose the best enumerables to perform the action required.

#### Test Driven Development - 3.5
  My test coverage does show 100% covered. I have tests for each method, irregardless if they live within the `Enigma` class or the respective modules. I did use stubs when testing for autogenerated keys and date (today's date). I wrote my tests before implementing the code and confirmed each line of code had a test to verify it's behavior. The only thing I did not use was mocks because I opted not to create multliple classes or a superclass.
